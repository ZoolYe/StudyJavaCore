集合类的由来：
	对象用于封装特有数据，对象多了就需要存储，如果对象的个数不确定，就使用集合容器进行存储
集合特点：
1，用于存储对象的容器
2，集合的长度是可变的
3，集合中不可以存储基本数据类型值

集合容器因为内部的数据结构不同，有多种具体容器，不断向上抽取，就形成了集合框架，框架的顶层Collection
框架的顶层Collection接口：
Collection的常见方法：
1，添加
	boolean add(Object obj);
	boolean addAll(Collection coll);
2，删除
	boolean remove(object obj);
	boolean removeAll(Collection coll);
	void clear();
3，判断
	boolean contains(Object obj);
	boolean containsAll(Collection coll);
	boolean isEmpty();
4，获取
	int size();
	Iterator iterator();取出元素的方式：迭代器
	该对象必须依赖于具体容器，因为每一个容器的数据结构都不同
	所以该迭代器对象是在容器内部实现的
5，其它
	boolean retainAll(Collection coll);取交集
	Object[] toArray();将集合转成数组
	
――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
Collection
	|--List:有序(存入和取出的顺序一致)，元素都有索引(角标)，元素可以重复。
	|--Set:元素不能重复，无序
	
List：特有的常见方法：有一个共性特点，就是都可以操作角标
	List集合是可以完成对元素的增删改查
1，添加
	void add(index,element);
	void add(index,collection);
2，删除
	Object remove(index);
3，修改
	Object set(index.element);
4，获取
	Object get(index);
	int indexOf(object);
	int lastIndexOf(object);
	List subList(from,to);
	
List集合是可以完成对元素的增删改查

List:
	|--Vector:内部是数组数据结构，是同步的，增删查询，都慢
	|--ArrayList:内部是数组数据结构，是不同步的，替代了Vector，查询的速度快
	|--LinkedList:内部链表数据结构，是不同步的，增删元素的速度很快
	
LinkedList:
	addFirst();
	addLast();
	jdk1.6
	offerFirst();
	offetLast();
	
	getFirst();//获取但不移除，如果链表为空，抛出NoSuchElementException
	getLast();
	jdk1.6
	peekFirst();//获取但不移除，如果链表为空，返回null
	peekLast();
	
	removeFirst();//获取并移除，如果链表为空，抛出NoSuchElementException
	removeLast();
	jdk1.6
	pollFirst();//获取并移除，如果链表为空，返回null
	pollLast();
	
________________________________________________________________

Set:元素不可以重复，是无序的
	Set接口中的方法和Collection一致
	|--HashSet:内部数据结构是哈希表，是不同步的
		
	|--TreeSet:




